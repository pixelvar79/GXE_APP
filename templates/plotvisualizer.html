<!-- 

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Field Trial Creator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />  
    <link rel="stylesheet" href="/static/css/styleshift.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.css" />

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>  
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <style>
        .hidden {
            display: none;
        }
        #layers-list {
            display: none;
        }
        .custom-dot-icon {
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <h1>Field Trial Creator</h1>
    <div class="container">
        <div class="column map-column">
            <h2>Visualizer</h2>
            <div id="map1" class="map">
                <div id="loading-message1" class="loading-message">Processing...</div>
            </div>
        </div>
        <div class="controls-container">
            <div class="column controls" id="automated-controls">
                <h2>Files controller</h2>
                <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;">
                <button id="upload-button" class="tab">Set Input Folder</button>
                <label for="ortho-select">Select Reference ORTHO:</label>
                <select id="ortho-select" class="tab"></select>
                <label for="shp-select">Select Reference SHP:</label>
                <select id="shp-select" class="tab"></select>
                <button onclick="resetSelectedPolygons()">Reset Selected Polygons</button>
                <button id="zoom-button" class="tab">Zoom to Active Layer</button>
                <button id="reset-button" class="tab">Reset Marks</button>
                <button id="save-edited-object-button" class="tab">Save Edited Object</button>
                <button id="send-selected-polygons" class="tab">Send Selected Polygons</button>
                <div id="layers-panel">
                    <h3 class="hidden">Loaded PNGs</h3>
                    <ul id="layers-list"></ul>
                </div>
                <button id="capture-coords-button" class="tab">Capture Initial and Direction Coordinates</button>
                <div id="selected-plots"></div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            var map1 = L.map('map1').setView([20, 0], 2);

            var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 40,
                attribution: '&copy; OpenStreetMap contributors'
            });
            
            osm.addTo(map1);

            // Initialize Geoman plugin
            map1.pm.addControls({
                position: 'topleft',
                drawMarker: true,
                drawPolygon: true,
                drawPolyline: true,
                editMode: true,
                removalMode: true,
            });

            // Add custom ruler tool using leaflet-measure plugin
            var measureControl = new L.Control.Measure({
                position: 'topleft',
                primaryLengthUnit: 'meters',
                secondaryLengthUnit: 'kilometers',
                primaryAreaUnit: 'sqmeters',
                secondaryAreaUnit: 'hectares',
                activeColor: '#ABE67E',
                completedColor: '#C8F2BE'
            });
            measureControl.addTo(map1);

            const layerControl1 = L.control.layers(null, null, { position: 'topright', collapsed: false }).addTo(map1);

            let geojsonLayers = {}; // Object to store GeoJSON layers by filename
            let selectedLayers = []; // Array to store selected layers
            let selectedPlots = []; // Array to store selected plots' order ID and GeoJSON path

            function loadGeoJSONFiles() {
                // Clear the shp-select dropdown to prevent duplication
                const shpSelect = document.getElementById("shp-select");
                shpSelect.innerHTML = '';

                // Load all .shifted.geojson files from Flask backend
                fetch('/list-geojson-files')
                    .then(response => response.json())
                    .then(files => {
                        files.forEach(file => {
                            // Fetch and add GeoJSON to the map
                            fetch(`/reprojected-geojson/${file}`)
                                .then(response => response.json())
                                .then(data => {
                                    const layer = L.geoJSON(data, {
                                        onEachFeature: function (feature, layer) {
                                            layer.on('mouseover', function (e) {
                                                const properties = feature.properties;
                                                let popupContent = '<div>';
                                                for (let key in properties) {
                                                    popupContent += `<strong>${key}:</strong> ${properties[key]}<br>`;
                                                }
                                                popupContent += '</div>';
                                                layer.bindPopup(popupContent).openPopup();
                                            });

                                            layer.on('mouseout', function (e) {
                                                // Close the popup
                                                layer.closePopup();
                                            });

                                            layer.on('click', function (e) {
                                                const properties = feature.properties;
                                                const orderID = properties.order; // Assuming 'order' is the property name
                                                const geojsonPath = file;

                                                // Check if the layer is already selected
                                                const index = selectedLayers.indexOf(layer);
                                                if (index === -1) {
                                                    // Change polygon color on click
                                                    layer.setStyle({
                                                        color: 'red'
                                                    });

                                                    // Add to selected layers and plots
                                                    selectedLayers.push(layer);
                                                    selectedPlots.push({ orderID, geojsonPath });

                                                    // Print the new plot added to the list
                                                    console.log(`New plot added: Order ID: ${orderID}, GeoJSON Path: ${geojsonPath}`);

                                                    // Print the updated list
                                                    console.log('Updated list of selected plots:', selectedPlots);

                                                    // Update the front end with the new plot and updated list
                                                    updateSelectedPlotsDisplay();
                                                }
                                            });
                                        }
                                    }).addTo(map1);
                                    geojsonLayers[file] = layer;

                                    // Add to shp-select dropdown
                                    const option = new Option(file, file);
                                    shpSelect.appendChild(option);

                                    // Add to layer control
                                    layerControl1.addOverlay(layer, file);

                                    // Optionally, adjust the map view to fit the loaded GeoJSON
                                    map1.fitBounds(layer.getBounds());
                                })
                                .catch(error => console.error('Error loading GeoJSON:', error));
                        });
                    });
            }

            // Function to clear all GeoJSON layers from the map
            function clearGeoJSONLayers() {
                for (const file in geojsonLayers) {
                    map1.removeLayer(geojsonLayers[file]);
                    layerControl1.removeLayer(geojsonLayers[file]);
                }
                geojsonLayers = {};
            }

            // Function to reset colors of all selected polygons and clear the selected plots list
            function resetSelectedPolygons() {
                clearGeoJSONLayers();
                selectedLayers = [];
                selectedPlots = [];
                updateSelectedPlotsDisplay();
                loadGeoJSONFiles();
            }

            // Function to update the display of selected plots in the front end
            function updateSelectedPlotsDisplay() {
                const selectedPlotsDiv = document.getElementById('selected-plots');
                selectedPlotsDiv.innerHTML = '<h3>Selected Plots:</h3>';
                selectedPlots.forEach(plot => {
                    selectedPlotsDiv.innerHTML += `<p>Order ID: ${plot.orderID}, GeoJSON Path: ${plot.geojsonPath}</p>`;
                });
            }

            // Function to send selected polygons to the backend
            function sendSelectedPolygons() {
                console.log('hello'); // Print hello when the button is clicked

                const data = {
                    selectedPlots: selectedPlots
                };

                console.log('Sending selected plots list data to the backend:', data);
                console.log('Selected plots list:', selectedPlots);

                fetch('/process-selected-polygons', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                })
                .then(response => response.json())
                .then(result => {
                    console.log('Statistics:', result);
                    // Handle the result (e.g., display it in the frontend)
                })
                .catch(error => console.error('Error:', error));
            }

            document.getElementById('upload-button').addEventListener('click', function() {
                document.getElementById('folder-input').click();
            });

            document.getElementById('folder-input').addEventListener('change', function(event) {
                const folderPath = event.target.files[0].webkitRelativePath.split('/')[0];
                document.getElementById('loading-message1').style.display = 'block';
                $.post('/process_images', { input_folder: folderPath }, function(data) {
                    let imagesLoaded = 0;
                    const totalImages = data.length;

                    data.forEach(item => {
                        if (item.png_path && item.bounds) {
                            const bounds = item.bounds;
                            const imageUrl = item.png_path;
                            const layer = L.imageOverlay(imageUrl, bounds);

                            layer.on('load', function() {
                                imagesLoaded++;
                                if (imagesLoaded === totalImages) {
                                    document.getElementById('loading-message1').style.display = 'none';
                                }
                            });

                            layer.addTo(map1);
                            const option = new Option(item.ortho_path, item.ortho_path);
                            $(option).data('original-ortho-path', item.original_ortho_path);
                            $('#ortho-select').append(option);
                            layerControl1.addOverlay(layer, item.ortho_path);

                            // Add to layers list
                            const listItem = document.createElement('li');
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = true;
                            checkbox.addEventListener('change', function() {
                                if (this.checked) {
                                    map1.addLayer(layer);
                                } else {
                                    map1.removeLayer(layer);
                                }
                            });
                            listItem.appendChild(checkbox);
                            listItem.appendChild(document.createTextNode(item.ortho_path));
                            document.getElementById('layers-list').appendChild(listItem);
                        }
                    });

                    // Load GeoJSON files after processing images
                    loadGeoJSONFiles();
                });
            });

            // Dropdown selectors for ortho images
            document.getElementById('ortho-select').addEventListener('change', function() {
                activeReferenceOrtho = this.value;
                const selectedOption = $('#ortho-select option:selected');
                originalReferenceOrthoPath = selectedOption.data('original-ortho-path');

                // Zoom to the selected reference ortho
                const selectedLayer = Object.values(layerControl1._layers).find(layer => layer.name === activeReferenceOrtho);
                if (selectedLayer) {
                    map1.fitBounds(selectedLayer.layer.getBounds());
                }
            });

            // Dropdown selectors for GeoJSON files
            document.getElementById('shp-select').addEventListener('change', function() {
                activeReferenceSHP = this.value;

                // Zoom to the selected reference GeoJSON
                const selectedLayer = geojsonLayers[activeReferenceSHP];
                if (selectedLayer) {
                    map1.fitBounds(selectedLayer.getBounds());
                }
            });

            // Add event listener to send selected polygons button
            document.getElementById('send-selected-polygons').addEventListener('click', function() {
                console.log('Button clicked'); // Test log to verify the event listener
                sendSelectedPolygons();
            });

            // Enable Leaflet.pm controls
            map1.pm.addControls({
                position: 'topleft',
                drawPolygon: true,
                editPolygon: true,
                rotateMode: true
            });

            // Enable rotation and dragging for selected polygons
            selectedPolygons.pm.enable({
                allowSelfIntersection: false,
                rotateMode: true,
                draggable: true
            });

            // Reference to the search polygon layer
            var searchPolygonLayer;

            // Add search control
            L.Control.geocoder({
                position: 'topleft',
                defaultMarkGeocode: false
            }).on('markgeocode', function(e) {
                var bbox = e.geocode.bbox;

                // Check if there is an existing polygon and remove it
                if (searchPolygonLayer) {
                    map1.removeLayer(searchPolygonLayer);
                }

                // Create a new polygon for the search result
                searchPolygonLayer = L.polygon([
                    [bbox.getSouthEast().lat, bbox.getSouthEast().lng],
                    [bbox.getNorthEast().lat, bbox.getNorthEast().lng],
                    [bbox.getNorthWest().lat, bbox.getNorthWest().lng],
                    [bbox.getSouthWest().lat, bbox.getSouthWest().lng]
                ]).addTo(map1);

                // Zoom to the polygon
                map1.fitBounds(searchPolygonLayer.getBounds());
            }).addTo(map1);

            // Listen to the zoomend event and remove the search polygon layer
            map1.on('zoomend', function() {
                if (searchPolygonLayer) {
                    map1.removeLayer(searchPolygonLayer);
                    searchPolygonLayer = null;
                }
            });

            function resetMarkers() {
                initialCorner = null;
                directionPoint = null;
                map1.eachLayer(function(layer) {
                    if (layer instanceof L.Marker) {
                        map1.removeLayer(layer);
                    }
                });
            }

            // Define a custom icon for the dot markers
            const dotIcon = L.divIcon({
                className: 'custom-dot-icon',
                html: '<div style="width: 8px; height: 8px; background-color: red; border-radius: 50%;"></div>',
                iconSize: [8, 8],
                iconAnchor: [4, 4]
            });

            // Change cursor to dot when approaching the target area
            map1.on('mousemove', function(e) {
                map1.getContainer().style.cursor = 'crosshair';
            });

            // Reset cursor when leaving the map
            map1.on('mouseout', function(e) {
                map1.getContainer().style.cursor = '';
            });

            // Reset markers
            document.getElementById('reset-button').addEventListener('click', function() {
                resetMarkers();
            });

            function resetMarkers() {
                initialCorner = null;
                directionPoint = null;
                map1.eachLayer(function(layer) {
                    if (layer instanceof L.Marker) {
                        map1.removeLayer(layer);
                    }
                });
            }
        });
    </script>
</body>
</html> -->



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plot Trial Analyzer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />  
    <link rel="stylesheet" href="/static/css/styleshift.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.css" />
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>  
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        if (typeof Chart !== 'undefined') {
            console.log('Chart.js is loaded and available.');
        } else {
            console.error('Chart.js is not loaded.');
        }
    </script>
    <style>
        .hidden {
            display: none;
        }
        #layers-list {
            display: none;
        }
        .custom-dot-icon {
            cursor: crosshair;
        }
        .container {
            display: flex;
            height: 100%;
        }
        .map-column {
            width: 50%;
            height: 100%;
        }
        .map {
            height: 100%;
        }
        .right-column {
            width: 50%;
            display: flex;
            flex-direction: column;
        }
        .controls-chart-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .controls-container {
            flex: 1;
            overflow-y: auto;
        }
        .chart-container {
            flex: 1;
        }
    </style>
</head>
<body>
    <h1>Plot Trial Analyzer</h1>
    <div class="container">
        <div class="column map-column">
            <h2>Map Visualizer</h2>
            <div id="map1" class="map">
                <div id="loading-message1" class="loading-message">Processing...</div>
            </div>
        </div>
        <div class="right-column">
            <div class="controls-chart-container">
                <div class="controls-container">
                    <div class="column controls" id="automated-controls">
                        <h2>Files controller</h2>
                        <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;">
                        <button id="upload-button" class="tab">Set Input Folder</button>
                        <label for="ortho-select">Select Reference ORTHO:</label>
                        <select id="ortho-select" class="tab"></select>
                        <label for="shp-select">Select Reference SHP:</label>
                        <select id="shp-select" class="tab"></select>
                        <button onclick="resetSelectedPolygons()">Reset Selected Polygons</button>
                        <button id="send-selected-polygons" class="tab">Send Selected Polygons</button>
                        <div id="layers-panel">
                            <h3 class="hidden">Loaded PNGs</h3>
                            <ul id="layers-list"></ul>
                        </div>
                        <div id="selected-plots"></div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="resultChart"></canvas>
                    
                </div>
                

            </div>
        </div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            var map1 = L.map('map1').setView([20, 0], 2);

            var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 40,
                attribution: '&copy; OpenStreetMap contributors'
            });
            
            osm.addTo(map1);

            // Initialize Geoman plugin
            map1.pm.addControls({
                position: 'topleft',
                drawMarker: true,
                drawPolygon: true,
                drawPolyline: true,
                editMode: true,
                removalMode: true,
            });

            // Add custom ruler tool using leaflet-measure plugin
            var measureControl = new L.Control.Measure({
                position: 'topleft',
                primaryLengthUnit: 'meters',
                secondaryLengthUnit: 'kilometers',
                primaryAreaUnit: 'sqmeters',
                secondaryAreaUnit: 'hectares',
                activeColor: '#ABE67E',
                completedColor: '#C8F2BE'
            });
            measureControl.addTo(map1);

            const layerControl1 = L.control.layers(null, null, { position: 'topright', collapsed: false }).addTo(map1);

            let geojsonLayers = {}; // Object to store GeoJSON layers by filename
            let selectedLayers = []; // Array to store selected layers
            let selectedPlots = []; // Array to store selected plots' order ID and GeoJSON path

            
            // Function to clear all GeoJSON layers from the map
            function clearGeoJSONLayers() {
                for (const file in geojsonLayers) {
                    map1.removeLayer(geojsonLayers[file]);
                    layerControl1.removeLayer(geojsonLayers[file]);
                }
                geojsonLayers = {};
            }

            // Function to reset colors of all selected polygons and clear the selected plots list
            function resetSelectedPolygons() {
                clearGeoJSONLayers();
                selectedLayers = [];
                selectedPlots = [];
                updateSelectedPlotsDisplay();
                loadGeoJSONFiles();
            }

        

            // Function to update the display of selected plots in the front end
            function updateSelectedPlotsDisplay() {
                const selectedPlotsDiv = document.getElementById('selected-plots');
                selectedPlotsDiv.innerHTML = '<h3>Selected Plots:</h3>';
                selectedPlots.forEach(plot => {
                    selectedPlotsDiv.innerHTML += `<p>Order ID: ${plot.orderID}, GeoJSON Path: ${plot.geojsonPath}</p>`;
                });
            }

            function loadGeoJSONFiles() {
                // Clear the shp-select dropdown to prevent duplication
                const shpSelect = document.getElementById("shp-select");
                shpSelect.innerHTML = '';

                // Load all .shifted.geojson files from Flask backend
                fetch('/list-geojson-files')
                    .then(response => response.json())
                    .then(files => {
                        files.forEach(file => {
                            // Fetch and add GeoJSON to the map
                            fetch(`/reprojected-geojson/${file}`)
                                .then(response => response.json())
                                .then(data => {
                                    const layer = L.geoJSON(data, {
                                        onEachFeature: function (feature, layer) {
                                            layer.on('mouseover', function (e) {
                                                const properties = feature.properties;
                                                let popupContent = '<div>';
                                                for (let key in properties) {
                                                    popupContent += `<strong>${key}:</strong> ${properties[key]}<br>`;
                                                }
                                                popupContent += '</div>';
                                                layer.bindPopup(popupContent).openPopup();
                                            });

                                            layer.on('mouseout', function (e) {
                                                // Close the popup
                                                layer.closePopup();
                                            });

                                            layer.on('click', function (e) {
                                                const properties = feature.properties;
                                                const orderID = properties.order; // Assuming 'order' is the property name
                                                const geojsonPath = file;

                                                // Check if the layer is already selected
                                                const index = selectedLayers.indexOf(layer);
                                                if (index === -1) {
                                                    // Change polygon color on click
                                                    layer.setStyle({
                                                        color: 'red'
                                                    });

                                                    // Add to selected layers and plots
                                                    selectedLayers.push(layer);
                                                    selectedPlots.push({ orderID, geojsonPath });

                                                    // Print the new plot added to the list
                                                    console.log(`New plot added: Order ID: ${orderID}, GeoJSON Path: ${geojsonPath}`);

                                                    // Print the updated list
                                                    console.log('Updated list of selected plots:', selectedPlots);

                                                    // Update the front end with the new plot and updated list
                                                    updateSelectedPlotsDisplay();
                                                }
                                            });
                                        }
                                    }).addTo(map1);
                                    geojsonLayers[file] = layer;

                                    // Add to shp-select dropdown
                                    const option = new Option(file, file);
                                    shpSelect.appendChild(option);

                                    // Add to layer control
                                    layerControl1.addOverlay(layer, file);

                                    // Optionally, adjust the map view to fit the loaded GeoJSON
                                    map1.fitBounds(layer.getBounds());
                                })
                                .catch(error => console.error('Error loading GeoJSON:', error));
                        });
                    });
            }


            // Function to send selected polygons to the backend and update the chart
            function sendSelectedPolygons() {
                console.log('hello'); // Print hello when the button is clicked

                const data = {
                    selectedPlots: selectedPlots
                };

                console.log('Sending selected plots list data to the backend:', data);
                console.log('Selected plots list:', selectedPlots);

                fetch('/process-selected-polygons', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                })
                .then(response => response.json())
                .then(result => {
                    console.log('Statistics:', result);
                    updateChart(result);
                })
                .catch(error => console.error('Error:', error));
            }

            // // Function to update the chart with new data
            // function updateChart(result) {
            //     const ctx = document.getElementById('resultChart').getContext('2d');
            //     const labels = result.map(item => item.Date_julian);
            //     const datasets = [
            //         {
            //             label: 'fcover',
            //             data: result.map(item => item.fcover),
            //             backgroundColor: 'rgba(255, 99, 132, 0.2)',
            //             borderColor: 'rgba(255, 99, 132, 1)',
            //             borderWidth: 1
            //         },
            //         {
            //             label: 'NDRE_max',
            //             data: result.map(item => item.NDRE_max),
            //             backgroundColor: 'rgba(54, 162, 235, 0.2)',
            //             borderColor: 'rgba(54, 162, 235, 1)',
            //             borderWidth: 1
            //         },
            //         {
            //             label: 'NDVI_max',
            //             data: result.map(item => item.NDVI_max),
            //             backgroundColor: 'rgba(75, 192, 192, 0.2)',
            //             borderColor: 'rgba(75, 192, 192, 1)',
            //             borderWidth: 1
            //         },
            //         {
            //             label: 'Band_6_max',
            //             data: result.map(item => item.Band_6_max),
            //             backgroundColor: 'rgba(153, 102, 255, 0.2)',
            //             borderColor: 'rgba(153, 102, 255, 1)',
            //             borderWidth: 1
            //         }
            //     ];

            //     // Check if window.resultChart is already initialized
            //     if (window.resultChart) {
            //         if (typeof window.resultChart.destroy === 'function') {
            //             window.resultChart.destroy();
            //         } else {
            //             console.error('window.resultChart.destroy is not a function');
            //         }
            //     }

            //     // Initialize the chart
            //     window.resultChart = new Chart(ctx, {
            //         type: 'bar',
            //         data: {
            //             labels: labels,
            //             datasets: datasets
            //         },
            //         options: {
            //             scales: {
            //                 x: {
            //                     beginAtZero: true
            //                 },
            //                 y: {
            //                     beginAtZero: true
            //                 }
            //             }
            //         }
            //     });
            // }

            document.getElementById('upload-button').addEventListener('click', function() {
                document.getElementById('folder-input').click();
            });

            // Function to get the dataset based on the selected trait
            function getSelectedDataset(result, trait) {
                const datasets = [];
                const plotColors = {};

                // Extract unique Date_julian values for labels
                const labels = [...new Set(result.map(item => String(item.Date_julian)))];

                // Group data by Date_julian and plotID
                const plotIDs = [...new Set(result.map(item => item.plotID))];
                plotIDs.forEach(plotID => {
                    const data = labels.map(date => {
                        const entry = result.find(item => String(item.Date_julian) === date && item.plotID === plotID);
                        return entry ? entry[trait] : 0;
                    });
                    if (!plotColors[plotID]) {
                        plotColors[plotID] = getRandomColor();
                    }
                    datasets.push({
                        label: `Plot ${plotID}`,
                        data: data,
                        backgroundColor: plotColors[plotID] + '80', // Add transparency
                        borderColor: plotColors[plotID],
                        borderWidth: 1
                    });
                });

                return { labels, datasets };
            }

            function updateChart(result) {
                const ctx = document.getElementById('resultChart').getContext('2d');
                
                // Extract unique Date_julian values and convert them to strings
                const labels = [...new Set(result.map(item => String(item.Date_julian)))];
                const plotIDs = [...new Set(result.map(item => item.plotID))];

                // Organize data for each plotID with its respective Date_julian values
                const datasets = plotIDs.map(plotID => {
                    // Filter data by plotID and organize by Date_julian for consistent bar placement
                    const data = labels.map(date => {
                        const entry = result.find(item => String(item.Date_julian) === date && item.plotID === plotID);
                        return entry ? entry.fcover : 0; // or use another metric like NDRE_max
                    });
                    return {
                        label: `Plot ${plotID}`,
                        data: data,
                        backgroundColor: `rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.6)`, // Random color for distinction
                        borderColor: 'rgba(0, 0, 0, 0.1)',
                        borderWidth: 1
                    };
                });

                // Destroy any existing chart instance before creating a new one
                // Check if window.resultChart is already initialized
                if (window.resultChart) {
                    if (typeof window.resultChart.destroy === 'function') {
                        window.resultChart.destroy();
                    } else {
                        console.error('window.resultChart.destroy is not a function');
                    }
                }

                // Create the new chart instance with grouped data by plotID
                window.resultChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels, // X-axis: unique `Date_julian` as strings
                        datasets: datasets
                    },
                    options: {
                        scales: {
                            x: {
                                beginAtZero: true,
                                stacked: false // Set to false to distinguish bars per plotID
                            },
                            y: {
                                beginAtZero: true
                            }
                        },
                        responsive: true,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            }
                        }
                    }
                });
            }












            document.getElementById('folder-input').addEventListener('change', function(event) {
                const folderPath = event.target.files[0].webkitRelativePath.split('/')[0];
                document.getElementById('loading-message1').style.display = 'block';
                $.post('/process_images', { input_folder: folderPath }, function(data) {
                    let imagesLoaded = 0;
                    const totalImages = data.length;

                    data.forEach(item => {
                        if (item.png_path && item.bounds) {
                            const bounds = item.bounds;
                            const imageUrl = item.png_path;
                            const layer = L.imageOverlay(imageUrl, bounds);

                            layer.on('load', function() {
                                imagesLoaded++;
                                if (imagesLoaded === totalImages) {
                                    document.getElementById('loading-message1').style.display = 'none';
                                }
                            });

                            layer.addTo(map1);
                            const option = new Option(item.ortho_path, item.ortho_path);
                            $(option).data('original-ortho-path', item.original_ortho_path);
                            $('#ortho-select').append(option);
                            layerControl1.addOverlay(layer, item.ortho_path);

                            // Add to layers list
                            const listItem = document.createElement('li');
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = true;
                            checkbox.addEventListener('change', function() {
                                if (this.checked) {
                                    map1.addLayer(layer);
                                } else {
                                    map1.removeLayer(layer);
                                }
                            });
                            listItem.appendChild(checkbox);
                            listItem.appendChild(document.createTextNode(item.ortho_path));
                            document.getElementById('layers-list').appendChild(listItem);
                        }
                    });

                    // Load GeoJSON files after processing images
                    loadGeoJSONFiles();
                });
            });

            // Dropdown selectors for ortho images
            document.getElementById('ortho-select').addEventListener('change', function() {
                activeReferenceOrtho = this.value;
                const selectedOption = $('#ortho-select option:selected');
                originalReferenceOrthoPath = selectedOption.data('original-ortho-path');

                // Zoom to the selected reference ortho
                const selectedLayer = Object.values(layerControl1._layers).find(layer => layer.name === activeReferenceOrtho);
                if (selectedLayer) {
                    map1.fitBounds(selectedLayer.layer.getBounds());
                }
            });

            // Dropdown selectors for GeoJSON files
            document.getElementById('shp-select').addEventListener('change', function() {
                activeReferenceSHP = this.value;

                // Zoom to the selected reference GeoJSON
                const selectedLayer = geojsonLayers[activeReferenceSHP];
                if (selectedLayer) {
                    map1.fitBounds(selectedLayer.getBounds());
                }
            });

            // Add event listener to send selected polygons button
            document.getElementById('send-selected-polygons').addEventListener('click', function() {
                console.log('Button clicked'); // Test log to verify the event listener
                sendSelectedPolygons();
            });

            // Enable Leaflet.pm controls
            map1.pm.addControls({
                position: 'topleft',
                drawPolygon: true,
                editPolygon: true,
                rotateMode: true
            });

            // Enable rotation and dragging for selected polygons
            selectedPolygons.pm.enable({
                allowSelfIntersection: false,
                rotateMode: true,
                draggable: true
            });

            // Reference to the search polygon layer
            var searchPolygonLayer;

            // Add search control
            L.Control.geocoder({
                position: 'topleft',
                defaultMarkGeocode: false
            }).on('markgeocode', function(e) {
                var bbox = e.geocode.bbox;

                // Check if there is an existing polygon and remove it
                if (searchPolygonLayer) {
                    map1.removeLayer(searchPolygonLayer);
                }

                // Create a new polygon for the search result
                searchPolygonLayer = L.polygon([
                    [bbox.getSouthEast().lat, bbox.getSouthEast().lng],
                    [bbox.getNorthEast().lat, bbox.getNorthEast().lng],
                    [bbox.getNorthWest().lat, bbox.getNorthWest().lng],
                    [bbox.getSouthWest().lat, bbox.getSouthWest().lng]
                ]).addTo(map1);

                // Zoom to the polygon
                map1.fitBounds(searchPolygonLayer.getBounds());
            }).addTo(map1);

            // Listen to the zoomend event and remove the search polygon layer
            map1.on('zoomend', function() {
                if (searchPolygonLayer) {
                    map1.removeLayer(searchPolygonLayer);
                    searchPolygonLayer = null;
                }
            });

            function resetMarkers() {
                initialCorner = null;
                directionPoint = null;
                map1.eachLayer(function(layer) {
                    if (layer instanceof L.Marker) {
                        map1.removeLayer(layer);
                    }
                });
            }

            // Define a custom icon for the dot markers
            const dotIcon = L.divIcon({
                className: 'custom-dot-icon',
                html: '<div style="width: 8px; height: 8px; background-color: red; border-radius: 50%;"></div>',
                iconSize: [8, 8],
                iconAnchor: [4, 4]
            });

            // Change cursor to dot when approaching the target area
            map1.on('mousemove', function(e) {
                map1.getContainer().style.cursor = 'crosshair';
            });

            // Reset cursor when leaving the map
            map1.on('mouseout', function(e) {
                map1.getContainer().style.cursor = '';
            });

            
        });
    </script>
</body>
</html>













<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plot Trial Analyzer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />  
    <link rel="stylesheet" href="/static/css/styleshift.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.css" />
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>  
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        if (typeof Chart !== 'undefined') {
            console.log('Chart.js is loaded and available.');
        } else {
            console.error('Chart.js is not loaded.');
        }
    </script>
    <style>
        .hidden {
            display: none;
        }
        #layers-list {
            display: none;
        }
        .custom-dot-icon {
            cursor: crosshair;
        }
        .container {
            display: flex;
            height: 100%;
        }
        .map-column {
            width: 50%;
            height: 100%;
        }
        .map {
            height: 100%;
        }
        .right-column {
            width: 50%;
            display: flex;
            flex-direction: column;
        }
        .controls-chart-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .controls-container {
            flex: 1;
            overflow-y: auto;
        }
        .chart-container {
            flex: 1;
        }
    </style>
</head>
<body>
    <h1>Plot Trial Analyzer</h1>
    <div class="container">
        <div class="column map-column">
            <h2>Map Visualizer</h2>
            <div id="map1" class="map">
                <div id="loading-message1" class="loading-message">Processing...</div>
            </div>
        </div>
        <div class="right-column">
            <div class="controls-chart-container">
                <div class="controls-container">
                    <div class="column controls" id="automated-controls">
                        <h2>Files controller</h2>
                        <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;">
                        <button id="upload-button" class="tab">Set Input Folder</button>
                        <label for="ortho-select">Select Reference ORTHO:</label>
                        <select id="ortho-select" class="tab"></select>
                        <label for="shp-select">Select Reference SHP:</label>
                        <select id="shp-select" class="tab"></select>
                        <button onclick="resetSelectedPolygons()">Reset Selected Polygons</button>
                        <button id="send-selected-polygons" class="tab">Send Selected Polygons</button>
                        <div id="layers-panel">
                            <h3 class="hidden">Loaded PNGs</h3>
                            <ul id="layers-list"></ul>
                        </div>
                        <div id="selected-plots"></div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="resultChart"></canvas>
                </div>
            </div>
        </div>
    </div>
    <script>
        let geojsonLayers = {}; // Object to store GeoJSON layers by filename
        let selectedLayers = []; // Array to store selected layers
        let selectedPlots = []; // Array to store selected plots' order ID and GeoJSON path

        // Function to clear all GeoJSON layers from the map
        function clearGeoJSONLayers() {
            for (const file in geojsonLayers) {
                map1.removeLayer(geojsonLayers[file]);
                layerControl1.removeLayer(geojsonLayers[file]);
            }
            geojsonLayers = {};
        }

        // Function to reset colors of all selected polygons and clear the selected plots list
        function resetSelectedPolygons() {
            clearGeoJSONLayers();
            selectedLayers = [];
            selectedPlots = [];
            updateSelectedPlotsDisplay();
            loadGeoJSONFiles();
        }

        // Function to update the display of selected plots in the front end
        function updateSelectedPlotsDisplay() {
            const selectedPlotsDiv = document.getElementById('selected-plots');
            selectedPlotsDiv.innerHTML = '<h3>Selected Plots:</h3>';
            selectedPlots.forEach(plot => {
                selectedPlotsDiv.innerHTML += `<p>Order ID: ${plot.orderID}, GeoJSON Path: ${plot.geojsonPath}</p>`;
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            var map1 = L.map('map1').setView([20, 0], 2);

            var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 40,
                attribution: '&copy; OpenStreetMap contributors'
            });
            
            osm.addTo(map1);

            // Initialize Geoman plugin
            map1.pm.addControls({
                position: 'topleft',
                drawMarker: true,
                drawPolygon: true,
                drawPolyline: true,
                editMode: true,
                removalMode: true,
            });

            // Add custom ruler tool using leaflet-measure plugin
            var measureControl = new L.Control.Measure({
                position: 'topleft',
                primaryLengthUnit: 'meters',
                secondaryLengthUnit: 'kilometers',
                primaryAreaUnit: 'sqmeters',
                secondaryAreaUnit: 'hectares',
                activeColor: '#ABE67E',
                completedColor: '#C8F2BE'
            });
            measureControl.addTo(map1);

            const layerControl1 = L.control.layers(null, null, { position: 'topright', collapsed: false }).addTo(map1);

            function loadGeoJSONFiles() {
                // Clear the shp-select dropdown to prevent duplication
                const shpSelect = document.getElementById("shp-select");
                shpSelect.innerHTML = '';

                // Load all .shifted.geojson files from Flask backend
                fetch('/list-geojson-files')
                    .then(response => response.json())
                    .then(files => {
                        files.forEach(file => {
                            // Fetch and add GeoJSON to the map
                            fetch(`/reprojected-geojson/${file}`)
                                .then(response => response.json())
                                .then(data => {
                                    const layer = L.geoJSON(data, {
                                        onEachFeature: function (feature, layer) {
                                            layer.on('mouseover', function (e) {
                                                const properties = feature.properties;
                                                let popupContent = '<div>';
                                                for (let key in properties) {
                                                    popupContent += `<strong>${key}:</strong> ${properties[key]}<br>`;
                                                }
                                                popupContent += '</div>';
                                                layer.bindPopup(popupContent).openPopup();
                                            });

                                            layer.on('mouseout', function (e) {
                                                // Close the popup
                                                layer.closePopup();
                                            });

                                            layer.on('click', function (e) {
                                                const properties = feature.properties;
                                                const orderID = properties.order; // Assuming 'order' is the property name
                                                const geojsonPath = file;

                                                // Check if the layer is already selected
                                                const index = selectedLayers.indexOf(layer);
                                                if (index === -1) {
                                                    // Change polygon color on click
                                                    layer.setStyle({
                                                        color: 'red'
                                                    });

                                                    // Add to selected layers and plots
                                                    selectedLayers.push(layer);
                                                    selectedPlots.push({ orderID, geojsonPath });

                                                    // Print the new plot added to the list
                                                    console.log(`New plot added: Order ID: ${orderID}, GeoJSON Path: ${geojsonPath}`);

                                                    // Print the updated list
                                                    console.log('Updated list of selected plots:', selectedPlots);

                                                    // Update the front end with the new plot and updated list
                                                    updateSelectedPlotsDisplay();
                                                }
                                            });
                                        }
                                    }).addTo(map1);
                                    geojsonLayers[file] = layer;

                                    // Add to shp-select dropdown
                                    const option = new Option(file, file);
                                    shpSelect.appendChild(option);

                                    // Add to layer control
                                    layerControl1.addOverlay(layer, file);

                                    // Optionally, adjust the map view to fit the loaded GeoJSON
                                    map1.fitBounds(layer.getBounds());
                                })
                                .catch(error => console.error('Error loading GeoJSON:', error));
                        });
                    });
            }

            // Function to send selected polygons to the backend and update the chart
            function sendSelectedPolygons() {
                console.log('hello'); // Print hello when the button is clicked

                const data = {
                    selectedPlots: selectedPlots
                };

                console.log('Sending selected plots list data to the backend:', data);
                console.log('Selected plots list:', selectedPlots);

                fetch('/process-selected-polygons', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                })
                .then(response => response.json())
                .then(result => {
                    console.log('Statistics:', result);
                    updateChart(result);
                })
                .catch(error => console.error('Error:', error));
            }

            // Function to update the chart with new data
            function updateChart(result) {
                const ctx = document.getElementById('resultChart').getContext('2d');
                const labels = result.map(item => item.Date_julian);
                const datasets = [
                    {
                        label: 'fcover',
                        data: result.map(item => item.fcover),
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'NDRE_max',
                        data: result.map(item => item.NDRE_max),
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'NDVI_max',
                        data: result.map(item => item.NDVI_max),
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    },
                    {
                        label: 'Band_6_max',
                        data: result.map(item => item.Band_6_max),
                        backgroundColor: 'rgba(153, 102, 255, 0.2)',
                        borderColor: 'rgba(153, 102, 255, 1)',
                        borderWidth: 1
                    }
                ];

                // Check if window.resultChart is already initialized
                if (window.resultChart) {
                    if (typeof window.resultChart.destroy === 'function') {
                        window.resultChart.destroy();
                    } else {
                        console.error('window.resultChart.destroy is not a function');
                    }
                }

                // Initialize the chart
                window.resultChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        scales: {
                            x: {
                                beginAtZero: true
                            },
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            document.getElementById('upload-button').addEventListener('click', function() {
                document.getElementById('folder-input').click();
            });

            document.getElementById('folder-input').addEventListener('change', function(event) {
                const folderPath = event.target.files[0].webkitRelativePath.split('/')[0];
                document.getElementById('loading-message1').style.display = 'block';
                $.post('/process_images', { input_folder: folderPath }, function(data) {
                    let imagesLoaded = 0;
                    const totalImages = data.length;

                    data.forEach(item => {
                        if (item.png_path && item.bounds) {
                            const bounds = item.bounds;
                            const imageUrl = item.png_path;
                            const layer = L.imageOverlay(imageUrl, bounds);

                            layer.on('load', function() {
                                imagesLoaded++;
                                if (imagesLoaded === totalImages) {
                                    document.getElementById('loading-message1').style.display = 'none';
                                }
                            });

                            layer.addTo(map1);
                            const option = new Option(item.ortho_path, item.ortho_path);
                            $(option).data('original-ortho-path', item.original_ortho_path);
                            $('#ortho-select').append(option);
                            layerControl1.addOverlay(layer, item.ortho_path);

                            // Add to layers list
                            const listItem = document.createElement('li');
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = true;
                            checkbox.addEventListener('change', function() {
                                if (this.checked) {
                                    map1.addLayer(layer);
                                } else {
                                    map1.removeLayer(layer);
                                }
                            });
                            listItem.appendChild(checkbox);
                            listItem.appendChild(document.createTextNode(item.ortho_path));
                            document.getElementById('layers-list').appendChild(listItem);
                        }
                    });

                    // Load GeoJSON files after processing images
                    loadGeoJSONFiles();
                });
            });

            // Dropdown selectors for ortho images
            document.getElementById('ortho-select').addEventListener('change', function() {
                activeReferenceOrtho = this.value;
                const selectedOption = $('#ortho-select option:selected');
                originalReferenceOrthoPath = selectedOption.data('original-ortho-path');

                // Zoom to the selected reference ortho
                const selectedLayer = Object.values(layerControl1._layers).find(layer => layer.name === activeReferenceOrtho);
                if (selectedLayer) {
                    map1.fitBounds(selectedLayer.layer.getBounds());
                }
            });

            // Dropdown selectors for GeoJSON files
            document.getElementById('shp-select').addEventListener('change', function() {
                activeReferenceSHP = this.value;

                // Zoom to the selected reference GeoJSON
                const selectedLayer = geojsonLayers[activeReferenceSHP];
                if (selectedLayer) {
                    map1.fitBounds(selectedLayer.getBounds());
                }
            });

            // Add event listener to send selected polygons button
            document.getElementById('send-selected-polygons').addEventListener('click', function() {
                console.log('Button clicked'); // Test log to verify the event listener
                sendSelectedPolygons();
            });

            // Enable Leaflet.pm controls
            map1.pm.addControls({
                position: 'topleft',
                drawPolygon: true,
                editPolygon: true,
                rotateMode: true
            });

            // Enable rotation and dragging for selected polygons
            selectedPolygons.pm.enable({
                allowSelfIntersection: false,
                rotateMode: true,
                draggable: true
            });

            // Reference to the search polygon layer
            var searchPolygonLayer;

            // Add search control
            L.Control.geocoder({
                position: 'topleft',
                defaultMarkGeocode: false
            }).on('markgeocode', function(e) {
                var bbox = e.geocode.bbox;

                // Check if there is an existing polygon and remove it
                if (searchPolygonLayer) {
                    map1.removeLayer(searchPolygonLayer);
                }

                // Create a new polygon for the search result
                searchPolygonLayer = L.polygon([
                    [bbox.getSouthEast().lat, bbox.getSouthEast().lng],
                    [bbox.getNorthEast().lat, bbox.getNorthEast().lng],
                    [bbox.getNorthWest().lat, bbox.getNorthWest().lng],
                    [bbox.getSouthWest().lat, bbox.getSouthWest().lng]
                ]).addTo(map1);

                // Zoom to the polygon
                map1.fitBounds(searchPolygonLayer.getBounds());
            }).addTo(map1);

            // Listen to the zoomend event and remove the search polygon layer
            map1.on('zoomend', function() {
                if (searchPolygonLayer) {
                    map1.removeLayer(searchPolygonLayer);
                    searchPolygonLayer = null;
                }
            });

            function resetMarkers() {
                initialCorner = null;
                directionPoint = null;
                map1.eachLayer(function(layer) {
                    if (layer instanceof L.Marker) {
                        map1.removeLayer(layer);
                    }
                });
            }

            // Define a custom icon for the dot markers
            const dotIcon = L.divIcon({
                className: 'custom-dot-icon',
                html: '<div style="width: 8px; height: 8px; background-color: red; border-radius: 50%;"></div>',
                iconSize: [8, 8],
                iconAnchor: [4, 4]
            });

            // Change cursor to dot when approaching the target area
            map1.on('mousemove', function(e) {
                map1.getContainer().style.cursor = 'crosshair';
            });

            // Reset cursor when leaving the map
            map1.on('mouseout', function(e) {
                map1.getContainer().style.cursor = '';
            });

            // Reset markers
            document.getElementById('reset-button').addEventListener('click', function() {
                resetMarkers();
            });

            function resetMarkers() {
                initialCorner = null;
                directionPoint = null;
                map1.eachLayer(function(layer) {
                    if (layer instanceof L.Marker) {
                        map1.removeLayer(layer);
                    }
                });
            }
        });
    </script>
</body>
</html> -->