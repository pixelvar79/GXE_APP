<!-- 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Field Trial Creator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />  
    <link rel="stylesheet" href="/static/css/styleshift.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.css" />

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>  
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <style>
        .hidden {
            display: none;
        }
        #layers-list {
            display: none;
        }
        .custom-dot-icon {
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <h1>Field Trial Creator</h1>
    <div class="container">
        <div class="column map-column">
            <h2>Visualizer</h2>
            <div id="map1" class="map">
                <div id="loading-message1" class="loading-message">Processing...</div>
            </div>
        </div>
        <div class="controls-container">
            <div class="column controls" id="automated-controls">
                <h2>Files controller</h2>
                <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;">
                <button id="upload-button" class="tab">Set Input Folder</button>
                <label for="ortho-select">Select Reference ORTHO:</label>
                <select id="ortho-select" class="tab"></select>
                <label for="shp-select">Select Reference SHP:</label>
                <select id="shp-select" class="tab"></select>
                <button onclick="resetSelectedPolygons()">Reset Selected Polygons</button>
                <button id="zoom-button" class="tab">Zoom to Active Layer</button>
                <button id="reset-button" class="tab">Reset Marks</button>
                <button id="save-edited-object-button" class="tab">Save Edited Object</button>
                <div id="layers-panel">
                    <h3 class="hidden">Loaded PNGs</h3>
                    <ul id="layers-list"></ul>
                </div>
                <button id="capture-coords-button" class="tab">Capture Initial and Direction Coordinates</button>
                <div id="selected-plots"></div>
            </div>
        </div>
    </div>

    <script>
        var map1 = L.map('map1').setView([20, 0], 2);

        var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 40,
            attribution: '&copy; OpenStreetMap contributors'
        });
        
        osm.addTo(map1);

        // Initialize Geoman plugin
        map1.pm.addControls({
            position: 'topleft',
            drawMarker: true,
            drawPolygon: true,
            drawPolyline: true,
            editMode: true,
            removalMode: true,
        });

        // Add custom ruler tool using leaflet-measure plugin
        var measureControl = new L.Control.Measure({
            position: 'topleft',
            primaryLengthUnit: 'meters',
            secondaryLengthUnit: 'kilometers',
            primaryAreaUnit: 'sqmeters',
            secondaryAreaUnit: 'hectares',
            activeColor: '#ABE67E',
            completedColor: '#C8F2BE'
        });
        measureControl.addTo(map1);

        const layerControl1 = L.control.layers(null, null, { position: 'topright', collapsed: false }).addTo(map1);

        let geojsonLayers = {}; // Object to store GeoJSON layers by filename
        let selectedLayers = []; // Array to store selected layers
        let selectedPlots = []; // Array to store selected plots' order ID and GeoJSON path

        function loadGeoJSONFiles() {
            // Load all .shifted.geojson files from Flask backend
            fetch('/list-geojson-files')
                .then(response => response.json())
                .then(files => {
                    const shpSelect = document.getElementById("shp-select");
                    files.forEach(file => {
                        // Fetch and add GeoJSON to the map
                        fetch(`/reprojected-geojson/${file}`)
                            .then(response => response.json())
                            .then(data => {
                                const layer = L.geoJSON(data, {
                                    onEachFeature: function (feature, layer) {
                                        layer.on('mouseover', function (e) {
                                            const properties = feature.properties;
                                            let popupContent = '<div>';
                                            for (let key in properties) {
                                                popupContent += `<strong>${key}:</strong> ${properties[key]}<br>`;
                                            }
                                            popupContent += '</div>';
                                            layer.bindPopup(popupContent).openPopup();
                                        });

                                        layer.on('mouseout', function (e) {
                                            // Close the popup
                                            layer.closePopup();
                                        });

                                        layer.on('click', function (e) {
                                            const properties = feature.properties;
                                            const orderID = properties.order; // Assuming 'order' is the property name
                                            const geojsonPath = file;

                                            // Check if the layer is already selected
                                            const index = selectedLayers.indexOf(layer);
                                            if (index === -1) {
                                                // Change polygon color on click
                                                layer.setStyle({
                                                    color: 'red'
                                                });

                                                // Add to selected layers and plots
                                                selectedLayers.push(layer);
                                                selectedPlots.push({ orderID, geojsonPath });

                                                // Print the new plot added to the list
                                                console.log(`New plot added: Order ID: ${orderID}, GeoJSON Path: ${geojsonPath}`);

                                                // Print the updated list
                                                console.log('Updated list of selected plots:', selectedPlots);

                                                // Update the front end with the new plot and updated list
                                                updateSelectedPlotsDisplay();
                                            }
                                        });
                                    }
                                }).addTo(map1);
                                geojsonLayers[file] = layer;

                                // Add to shp-select dropdown
                                const option = new Option(file, file);
                                shpSelect.appendChild(option);

                                // Add to layer control
                                layerControl1.addOverlay(layer, file);

                                // Optionally, adjust the map view to fit the loaded GeoJSON
                                map1.fitBounds(layer.getBounds());
                            })
                            .catch(error => console.error('Error loading GeoJSON:', error));
                    });
                });
        }

        // Function to toggle visibility of a layer
        function toggleLayer(filename) {
            if (geojsonLayers[filename]) {
                if (map1.hasLayer(geojsonLayers[filename])) {
                    map1.removeLayer(geojsonLayers[filename]);
                } else {
                    map1.addLayer(geojsonLayers[filename]);
                }
            }
        }

        // Function to reset colors of all selected polygons and clear the selected plots list
        function resetSelectedPolygons() {
            selectedLayers.forEach(layer => {
                layer.setStyle({
                    color: 'blue'
                });
            });
            selectedLayers = [];
            selectedPlots = [];
            updateSelectedPlotsDisplay();
        }

        // Function to update the display of selected plots in the front end
        function updateSelectedPlotsDisplay() {
            const selectedPlotsDiv = document.getElementById('selected-plots');
            selectedPlotsDiv.innerHTML = '<h3>Selected Plots:</h3>';
            selectedPlots.forEach(plot => {
                selectedPlotsDiv.innerHTML += `<p>Order ID: ${plot.orderID}, GeoJSON Path: ${plot.geojsonPath}</p>`;
            });
        }

        document.getElementById('upload-button').addEventListener('click', function() {
            document.getElementById('folder-input').click();
        });

        document.getElementById('folder-input').addEventListener('change', function(event) {
            const folderPath = event.target.files[0].webkitRelativePath.split('/')[0];
            document.getElementById('loading-message1').style.display = 'block';
            $.post('/process_images', { input_folder: folderPath }, function(data) {
                let imagesLoaded = 0;
                const totalImages = data.length;

                data.forEach(item => {
                    if (item.png_path && item.bounds) {
                        const bounds = item.bounds;
                        const imageUrl = item.png_path;
                        const layer = L.imageOverlay(imageUrl, bounds);

                        layer.on('load', function() {
                            imagesLoaded++;
                            if (imagesLoaded === totalImages) {
                                document.getElementById('loading-message1').style.display = 'none';
                            }
                        });

                        layer.addTo(map1);
                        const option = new Option(item.ortho_path, item.ortho_path);
                        $(option).data('original-ortho-path', item.original_ortho_path);
                        $('#ortho-select').append(option);
                        layerControl1.addOverlay(layer, item.ortho_path);

                        // Add to layers list
                        const listItem = document.createElement('li');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.checked = true;
                        checkbox.addEventListener('change', function() {
                            if (this.checked) {
                                map1.addLayer(layer);
                            } else {
                                map1.removeLayer(layer);
                            }
                        });
                        listItem.appendChild(checkbox);
                        listItem.appendChild(document.createTextNode(item.ortho_path));
                        document.getElementById('layers-list').appendChild(listItem);
                    }
                });

                // Load GeoJSON files after processing images
                loadGeoJSONFiles();
            });
        });

        // Dropdown selectors for ortho images
        document.getElementById('ortho-select').addEventListener('change', function() {
            activeReferenceOrtho = this.value;
            const selectedOption = $('#ortho-select option:selected');
            originalReferenceOrthoPath = selectedOption.data('original-ortho-path');

            // Zoom to the selected reference ortho
            const selectedLayer = Object.values(layerControl1._layers).find(layer => layer.name === activeReferenceOrtho);
            if (selectedLayer) {
                map1.fitBounds(selectedLayer.layer.getBounds());
            }
        });

        // Dropdown selectors for GeoJSON files
        document.getElementById('shp-select').addEventListener('change', function() {
            activeReferenceSHP = this.value;

            // Zoom to the selected reference GeoJSON
            const selectedLayer = geojsonLayers[activeReferenceSHP];
            if (selectedLayer) {
                map1.fitBounds(selectedLayer.getBounds());
            }
        });

        // Enable Leaflet.pm controls
        map1.pm.addControls({
            position: 'topleft',
            drawPolygon: true,
            editPolygon: true,
            rotateMode: true
        });

        // Enable rotation and dragging for selected polygons
        selectedPolygons.pm.enable({
            allowSelfIntersection: false,
            rotateMode: true,
            draggable: true
        });

        // Reference to the search polygon layer
        var searchPolygonLayer;

        // Add search control
        L.Control.geocoder({
            position: 'topleft',
            defaultMarkGeocode: false
        }).on('markgeocode', function(e) {
            var bbox = e.geocode.bbox;

            // Check if there is an existing polygon and remove it
            if (searchPolygonLayer) {
                map1.removeLayer(searchPolygonLayer);
            }

            // Create a new polygon for the search result
            searchPolygonLayer = L.polygon([
                [bbox.getSouthEast().lat, bbox.getSouthEast().lng],
                [bbox.getNorthEast().lat, bbox.getNorthEast().lng],
                [bbox.getNorthWest().lat, bbox.getNorthWest().lng],
                [bbox.getSouthWest().lat, bbox.getSouthWest().lng]
            ]).addTo(map1);

            // Zoom to the polygon
            map1.fitBounds(searchPolygonLayer.getBounds());
        }).addTo(map1);

        // Listen to the zoomend event and remove the search polygon layer
        map1.on('zoomend', function() {
            if (searchPolygonLayer) {
                map1.removeLayer(searchPolygonLayer);
                searchPolygonLayer = null;
            }
        });

        function resetMarkers() {
            initialCorner = null;
            directionPoint = null;
            map1.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    map1.removeLayer(layer);
                }
            });
        }

        // Define a custom icon for the dot markers
        const dotIcon = L.divIcon({
            className: 'custom-dot-icon',
            html: '<div style="width: 8px; height: 8px; background-color: red; border-radius: 50%;"></div>',
            iconSize: [8, 8],
            iconAnchor: [4, 4]
        });

        // Change cursor to dot when approaching the target area
        map1.on('mousemove', function(e) {
            map1.getContainer().style.cursor = 'crosshair';
        });

        // Reset cursor when leaving the map
        map1.on('mouseout', function(e) {
            map1.getContainer().style.cursor = '';
        });

        // Reset markers
        document.getElementById('reset-button').addEventListener('click', function() {
            resetMarkers();
        });

        function resetMarkers() {
            initialCorner = null;
            directionPoint = null;
            map1.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    map1.removeLayer(layer);
                }
            });
        }

    </script>
</body>
</html> -->


<!-- <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Field Trial Creator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />  
    <link rel="stylesheet" href="/static/css/styleshift.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.css" />

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>  
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <style>
        .hidden {
            display: none;
        }
        #layers-list {
            display: none;
        }
        .custom-dot-icon {
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <h1>Field Trial Creator</h1>
    <div class="container">
        <div class="column map-column">
            <h2>Visualizer</h2>
            <div id="map1" class="map">
                <div id="loading-message1" class="loading-message">Processing...</div>
            </div>
        </div>
        <div class="controls-container">
            <div class="column controls" id="automated-controls">
                <h2>Files controller</h2>
                <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;">
                <button id="upload-button" class="tab">Set Input Folder</button>
                <label for="ortho-select">Select Reference ORTHO:</label>
                <select id="ortho-select" class="tab"></select>
                <label for="shp-select">Select Reference SHP:</label>
                <select id="shp-select" class="tab"></select>
                <button onclick="resetSelectedPolygons()">Reset Selected Polygons</button>
                <button id="zoom-button" class="tab">Zoom to Active Layer</button>
                <button id="reset-button" class="tab">Reset Marks</button>
                <button id="save-edited-object-button" class="tab">Save Edited Object</button>
                <div id="layers-panel">
                    <h3 class="hidden">Loaded PNGs</h3>
                    <ul id="layers-list"></ul>
                </div>
                <button id="capture-coords-button" class="tab">Capture Initial and Direction Coordinates</button>
                <div id="selected-plots"></div>
            </div>
        </div>
    </div>

    <script>
        var map1 = L.map('map1').setView([20, 0], 2);

        var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 40,
            attribution: '&copy; OpenStreetMap contributors'
        });
        
        osm.addTo(map1);

        // Initialize Geoman plugin
        map1.pm.addControls({
            position: 'topleft',
            drawMarker: true,
            drawPolygon: true,
            drawPolyline: true,
            editMode: true,
            removalMode: true,
        });

        // Add custom ruler tool using leaflet-measure plugin
        var measureControl = new L.Control.Measure({
            position: 'topleft',
            primaryLengthUnit: 'meters',
            secondaryLengthUnit: 'kilometers',
            primaryAreaUnit: 'sqmeters',
            secondaryAreaUnit: 'hectares',
            activeColor: '#ABE67E',
            completedColor: '#C8F2BE'
        });
        measureControl.addTo(map1);

        const layerControl1 = L.control.layers(null, null, { position: 'topright', collapsed: false }).addTo(map1);

        let geojsonLayers = {}; // Object to store GeoJSON layers by filename
        let selectedLayers = []; // Array to store selected layers
        let selectedPlots = []; // Array to store selected plots' order ID and GeoJSON path
        let originalStyles = new Map(); // Map to store original styles of layers

        function loadGeoJSONFiles() {
            // Load all .shifted.geojson files from Flask backend
            fetch('/list-geojson-files')
                .then(response => response.json())
                .then(files => {
                    const shpSelect = document.getElementById("shp-select");
                    files.forEach(file => {
                        // Fetch and add GeoJSON to the map
                        fetch(`/reprojected-geojson/${file}`)
                            .then(response => response.json())
                            .then(data => {
                                const layer = L.geoJSON(data, {
                                    onEachFeature: function (feature, layer) {
                                        // Store the original style
                                        originalStyles.set(layer, layer.options.style || {});

                                        layer.on('mouseover', function (e) {
                                            const properties = feature.properties;
                                            let popupContent = '<div>';
                                            for (let key in properties) {
                                                popupContent += `<strong>${key}:</strong> ${properties[key]}<br>`;
                                            }
                                            popupContent += '</div>';
                                            layer.bindPopup(popupContent).openPopup();
                                        });

                                        layer.on('mouseout', function (e) {
                                            // Close the popup
                                            layer.closePopup();
                                        });

                                        layer.on('click', function (e) {
                                            const properties = feature.properties;
                                            const orderID = properties.order; // Assuming 'order' is the property name
                                            const geojsonPath = file;

                                            // Check if the layer is already selected
                                            const index = selectedLayers.indexOf(layer);
                                            if (index === -1) {
                                                // Change polygon color on click
                                                layer.setStyle({
                                                    color: 'red'
                                                });

                                                // Add to selected layers and plots
                                                selectedLayers.push(layer);
                                                selectedPlots.push({ orderID, geojsonPath });

                                                // Print the new plot added to the list
                                                console.log(`New plot added: Order ID: ${orderID}, GeoJSON Path: ${geojsonPath}`);

                                                // Print the updated list
                                                console.log('Updated list of selected plots:', selectedPlots);

                                                // Update the front end with the new plot and updated list
                                                updateSelectedPlotsDisplay();
                                            }
                                        });
                                    }
                                }).addTo(map1);
                                geojsonLayers[file] = layer;

                                // Add to shp-select dropdown
                                const option = new Option(file, file);
                                shpSelect.appendChild(option);

                                // Add to layer control
                                layerControl1.addOverlay(layer, file);

                                // Optionally, adjust the map view to fit the loaded GeoJSON
                                map1.fitBounds(layer.getBounds());
                            })
                            .catch(error => console.error('Error loading GeoJSON:', error));
                    });
                });
        }

        // Function to toggle visibility of a layer
        function toggleLayer(filename) {
            if (geojsonLayers[filename]) {
                if (map1.hasLayer(geojsonLayers[filename])) {
                    map1.removeLayer(geojsonLayers[filename]);
                } else {
                    map1.addLayer(geojsonLayers[filename]);
                }
            }
        }

        // Function to reset colors of all selected polygons and clear the selected plots list
        function resetSelectedPolygons() {
            selectedLayers.forEach(layer => {
                // Reset to original style
                layer.setStyle(originalStyles.get(layer));
            });
            selectedLayers = [];
            selectedPlots = [];
            updateSelectedPlotsDisplay();
        }

        // Function to update the display of selected plots in the front end
        function updateSelectedPlotsDisplay() {
            const selectedPlotsDiv = document.getElementById('selected-plots');
            selectedPlotsDiv.innerHTML = '<h3>Selected Plots:</h3>';
            selectedPlots.forEach(plot => {
                selectedPlotsDiv.innerHTML += `<p>Order ID: ${plot.orderID}, GeoJSON Path: ${plot.geojsonPath}</p>`;
            });
        }

        document.getElementById('upload-button').addEventListener('click', function() {
            document.getElementById('folder-input').click();
        });

        document.getElementById('folder-input').addEventListener('change', function(event) {
            const folderPath = event.target.files[0].webkitRelativePath.split('/')[0];
            document.getElementById('loading-message1').style.display = 'block';
            $.post('/process_images', { input_folder: folderPath }, function(data) {
                let imagesLoaded = 0;
                const totalImages = data.length;

                data.forEach(item => {
                    if (item.png_path && item.bounds) {
                        const bounds = item.bounds;
                        const imageUrl = item.png_path;
                        const layer = L.imageOverlay(imageUrl, bounds);

                        layer.on('load', function() {
                            imagesLoaded++;
                            if (imagesLoaded === totalImages) {
                                document.getElementById('loading-message1').style.display = 'none';
                            }
                        });

                        layer.addTo(map1);
                        const option = new Option(item.ortho_path, item.ortho_path);
                        $(option).data('original-ortho-path', item.original_ortho_path);
                        $('#ortho-select').append(option);
                        layerControl1.addOverlay(layer, item.ortho_path);

                        // Add to layers list
                        const listItem = document.createElement('li');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.checked = true;
                        checkbox.addEventListener('change', function() {
                            if (this.checked) {
                                map1.addLayer(layer);
                            } else {
                                map1.removeLayer(layer);
                            }
                        });
                        listItem.appendChild(checkbox);
                        listItem.appendChild(document.createTextNode(item.ortho_path));
                        document.getElementById('layers-list').appendChild(listItem);
                    }
                });

                // Load GeoJSON files after processing images
                loadGeoJSONFiles();
            });
        });

        // Dropdown selectors for ortho images
        document.getElementById('ortho-select').addEventListener('change', function() {
            activeReferenceOrtho = this.value;
            const selectedOption = $('#ortho-select option:selected');
            originalReferenceOrthoPath = selectedOption.data('original-ortho-path');

            // Zoom to the selected reference ortho
            const selectedLayer = Object.values(layerControl1._layers).find(layer => layer.name === activeReferenceOrtho);
            if (selectedLayer) {
                map1.fitBounds(selectedLayer.layer.getBounds());
            }
        });

        // Dropdown selectors for GeoJSON files
        document.getElementById('shp-select').addEventListener('change', function() {
            activeReferenceSHP = this.value;

            // Zoom to the selected reference GeoJSON
            const selectedLayer = geojsonLayers[activeReferenceSHP];
            if (selectedLayer) {
                map1.fitBounds(selectedLayer.getBounds());
            }
        });

        // Enable Leaflet.pm controls
        map1.pm.addControls({
            position: 'topleft',
            drawPolygon: true,
            editPolygon: true,
            rotateMode: true
        });

        // Enable rotation and dragging for selected polygons
        selectedPolygons.pm.enable({
            allowSelfIntersection: false,
            rotateMode: true,
            draggable: true
        });

        // Reference to the search polygon layer
        var searchPolygonLayer;

        // Add search control
        L.Control.geocoder({
            position: 'topleft',
            defaultMarkGeocode: false
        }).on('markgeocode', function(e) {
            var bbox = e.geocode.bbox;

            // Check if there is an existing polygon and remove it
            if (searchPolygonLayer) {
                map1.removeLayer(searchPolygonLayer);
            }

            // Create a new polygon for the search result
            searchPolygonLayer = L.polygon([
                [bbox.getSouthEast().lat, bbox.getSouthEast().lng],
                [bbox.getNorthEast().lat, bbox.getNorthEast().lng],
                [bbox.getNorthWest().lat, bbox.getNorthWest().lng],
                [bbox.getSouthWest().lat, bbox.getSouthWest().lng]
            ]).addTo(map1);

            // Zoom to the polygon
            map1.fitBounds(searchPolygonLayer.getBounds());
        }).addTo(map1);

        // Listen to the zoomend event and remove the search polygon layer
        map1.on('zoomend', function() {
            if (searchPolygonLayer) {
                map1.removeLayer(searchPolygonLayer);
                searchPolygonLayer = null;
            }
        });

        function resetMarkers() {
            initialCorner = null;
            directionPoint = null;
            map1.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    map1.removeLayer(layer);
                }
            });
        }

        // Define a custom icon for the dot markers
        const dotIcon = L.divIcon({
            className: 'custom-dot-icon',
            html: '<div style="width: 8px; height: 8px; background-color: red; border-radius: 50%;"></div>',
            iconSize: [8, 8],
            iconAnchor: [4, 4]
        });

        // Change cursor to dot when approaching the target area
        map1.on('mousemove', function(e) {
            map1.getContainer().style.cursor = 'crosshair';
        });

        // Reset cursor when leaving the map
        map1.on('mouseout', function(e) {
            map1.getContainer().style.cursor = '';
        });

        // Reset markers
        document.getElementById('reset-button').addEventListener('click', function() {
            resetMarkers();
        });

        function resetMarkers() {
            initialCorner = null;
            directionPoint = null;
            map1.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    map1.removeLayer(layer);
                }
            });
        }

    </script>
</body>
</html> -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Field Trial Creator</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" />  
    <link rel="stylesheet" href="/static/css/styleshift.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.css" />

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js"></script>  
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
    <script src="https://cdn.jsdelivr.net/npm/leaflet-measure/dist/leaflet-measure.js"></script>
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    <style>
        .hidden {
            display: none;
        }
        #layers-list {
            display: none;
        }
        .custom-dot-icon {
            cursor: crosshair;
        }
    </style>
</head>
<body>
    <h1>Field Trial Creator</h1>
    <div class="container">
        <div class="column map-column">
            <h2>Visualizer</h2>
            <div id="map1" class="map">
                <div id="loading-message1" class="loading-message">Processing...</div>
            </div>
        </div>
        <div class="controls-container">
            <div class="column controls" id="automated-controls">
                <h2>Files controller</h2>
                <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;">
                <button id="upload-button" class="tab">Set Input Folder</button>
                <label for="ortho-select">Select Reference ORTHO:</label>
                <select id="ortho-select" class="tab"></select>
                <label for="shp-select">Select Reference SHP:</label>
                <select id="shp-select" class="tab"></select>
                <button onclick="resetSelectedPolygons()">Reset Selected Polygons</button>
                <button id="zoom-button" class="tab">Zoom to Active Layer</button>
                <button id="reset-button" class="tab">Reset Marks</button>
                <button id="save-edited-object-button" class="tab">Save Edited Object</button>
                <div id="layers-panel">
                    <h3 class="hidden">Loaded PNGs</h3>
                    <ul id="layers-list"></ul>
                </div>
                <button id="capture-coords-button" class="tab">Capture Initial and Direction Coordinates</button>
                <div id="selected-plots"></div>
            </div>
        </div>
    </div>

    <script>
        var map1 = L.map('map1').setView([20, 0], 2);

        var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 40,
            attribution: '&copy; OpenStreetMap contributors'
        });
        
        osm.addTo(map1);

        // Initialize Geoman plugin
        map1.pm.addControls({
            position: 'topleft',
            drawMarker: true,
            drawPolygon: true,
            drawPolyline: true,
            editMode: true,
            removalMode: true,
        });

        // Add custom ruler tool using leaflet-measure plugin
        var measureControl = new L.Control.Measure({
            position: 'topleft',
            primaryLengthUnit: 'meters',
            secondaryLengthUnit: 'kilometers',
            primaryAreaUnit: 'sqmeters',
            secondaryAreaUnit: 'hectares',
            activeColor: '#ABE67E',
            completedColor: '#C8F2BE'
        });
        measureControl.addTo(map1);

        const layerControl1 = L.control.layers(null, null, { position: 'topright', collapsed: false }).addTo(map1);

        let geojsonLayers = {}; // Object to store GeoJSON layers by filename
        let selectedLayers = []; // Array to store selected layers
        let selectedPlots = []; // Array to store selected plots' order ID and GeoJSON path

        function loadGeoJSONFiles() {
            // Load all .shifted.geojson files from Flask backend
            fetch('/list-geojson-files')
                .then(response => response.json())
                .then(files => {
                    const shpSelect = document.getElementById("shp-select");
                    files.forEach(file => {
                        // Fetch and add GeoJSON to the map
                        fetch(`/reprojected-geojson/${file}`)
                            .then(response => response.json())
                            .then(data => {
                                const layer = L.geoJSON(data, {
                                    onEachFeature: function (feature, layer) {
                                        layer.on('mouseover', function (e) {
                                            const properties = feature.properties;
                                            let popupContent = '<div>';
                                            for (let key in properties) {
                                                popupContent += `<strong>${key}:</strong> ${properties[key]}<br>`;
                                            }
                                            popupContent += '</div>';
                                            layer.bindPopup(popupContent).openPopup();
                                        });

                                        layer.on('mouseout', function (e) {
                                            // Close the popup
                                            layer.closePopup();
                                        });

                                        layer.on('click', function (e) {
                                            const properties = feature.properties;
                                            const orderID = properties.order; // Assuming 'order' is the property name
                                            const geojsonPath = file;

                                            // Check if the layer is already selected
                                            const index = selectedLayers.indexOf(layer);
                                            if (index === -1) {
                                                // Change polygon color on click
                                                layer.setStyle({
                                                    color: 'red'
                                                });

                                                // Add to selected layers and plots
                                                selectedLayers.push(layer);
                                                selectedPlots.push({ orderID, geojsonPath });

                                                // Print the new plot added to the list
                                                console.log(`New plot added: Order ID: ${orderID}, GeoJSON Path: ${geojsonPath}`);

                                                // Print the updated list
                                                console.log('Updated list of selected plots:', selectedPlots);

                                                // Update the front end with the new plot and updated list
                                                updateSelectedPlotsDisplay();
                                            }
                                        });
                                    }
                                }).addTo(map1);
                                geojsonLayers[file] = layer;

                                // Add to shp-select dropdown
                                const option = new Option(file, file);
                                shpSelect.appendChild(option);

                                // Add to layer control
                                layerControl1.addOverlay(layer, file);

                                // Optionally, adjust the map view to fit the loaded GeoJSON
                                map1.fitBounds(layer.getBounds());
                            })
                            .catch(error => console.error('Error loading GeoJSON:', error));
                    });
                });
        }

        // Function to clear all GeoJSON layers from the map
        function clearGeoJSONLayers() {
            for (const file in geojsonLayers) {
                map1.removeLayer(geojsonLayers[file]);
                layerControl1.removeLayer(geojsonLayers[file]);
            }
            geojsonLayers = {};
        }

        // Function to reset colors of all selected polygons and clear the selected plots list
        function resetSelectedPolygons() {
            clearGeoJSONLayers();
            selectedLayers = [];
            selectedPlots = [];
            updateSelectedPlotsDisplay();
            loadGeoJSONFiles();
        }

        // Function to update the display of selected plots in the front end
        function updateSelectedPlotsDisplay() {
            const selectedPlotsDiv = document.getElementById('selected-plots');
            selectedPlotsDiv.innerHTML = '<h3>Selected Plots:</h3>';
            selectedPlots.forEach(plot => {
                selectedPlotsDiv.innerHTML += `<p>Order ID: ${plot.orderID}, GeoJSON Path: ${plot.geojsonPath}</p>`;
            });
        }

        document.getElementById('upload-button').addEventListener('click', function() {
            document.getElementById('folder-input').click();
        });

        document.getElementById('folder-input').addEventListener('change', function(event) {
            const folderPath = event.target.files[0].webkitRelativePath.split('/')[0];
            document.getElementById('loading-message1').style.display = 'block';
            $.post('/process_images', { input_folder: folderPath }, function(data) {
                let imagesLoaded = 0;
                const totalImages = data.length;

                data.forEach(item => {
                    if (item.png_path && item.bounds) {
                        const bounds = item.bounds;
                        const imageUrl = item.png_path;
                        const layer = L.imageOverlay(imageUrl, bounds);

                        layer.on('load', function() {
                            imagesLoaded++;
                            if (imagesLoaded === totalImages) {
                                document.getElementById('loading-message1').style.display = 'none';
                            }
                        });

                        layer.addTo(map1);
                        const option = new Option(item.ortho_path, item.ortho_path);
                        $(option).data('original-ortho-path', item.original_ortho_path);
                        $('#ortho-select').append(option);
                        layerControl1.addOverlay(layer, item.ortho_path);

                        // Add to layers list
                        const listItem = document.createElement('li');
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.checked = true;
                        checkbox.addEventListener('change', function() {
                            if (this.checked) {
                                map1.addLayer(layer);
                            } else {
                                map1.removeLayer(layer);
                            }
                        });
                        listItem.appendChild(checkbox);
                        listItem.appendChild(document.createTextNode(item.ortho_path));
                        document.getElementById('layers-list').appendChild(listItem);
                    }
                });

                // Load GeoJSON files after processing images
                loadGeoJSONFiles();
            });
        });

        // Dropdown selectors for ortho images
        document.getElementById('ortho-select').addEventListener('change', function() {
            activeReferenceOrtho = this.value;
            const selectedOption = $('#ortho-select option:selected');
            originalReferenceOrthoPath = selectedOption.data('original-ortho-path');

            // Zoom to the selected reference ortho
            const selectedLayer = Object.values(layerControl1._layers).find(layer => layer.name === activeReferenceOrtho);
            if (selectedLayer) {
                map1.fitBounds(selectedLayer.layer.getBounds());
            }
        });

        // Dropdown selectors for GeoJSON files
        document.getElementById('shp-select').addEventListener('change', function() {
            activeReferenceSHP = this.value;

            // Zoom to the selected reference GeoJSON
            const selectedLayer = geojsonLayers[activeReferenceSHP];
            if (selectedLayer) {
                map1.fitBounds(selectedLayer.getBounds());
            }
        });

        // Enable Leaflet.pm controls
        map1.pm.addControls({
            position: 'topleft',
            drawPolygon: true,
            editPolygon: true,
            rotateMode: true
        });

        // Enable rotation and dragging for selected polygons
        selectedPolygons.pm.enable({
            allowSelfIntersection: false,
            rotateMode: true,
            draggable: true
        });

        // Reference to the search polygon layer
        var searchPolygonLayer;

        // Add search control
        L.Control.geocoder({
            position: 'topleft',
            defaultMarkGeocode: false
        }).on('markgeocode', function(e) {
            var bbox = e.geocode.bbox;

            // Check if there is an existing polygon and remove it
            if (searchPolygonLayer) {
                map1.removeLayer(searchPolygonLayer);
            }

            // Create a new polygon for the search result
            searchPolygonLayer = L.polygon([
                [bbox.getSouthEast().lat, bbox.getSouthEast().lng],
                [bbox.getNorthEast().lat, bbox.getNorthEast().lng],
                [bbox.getNorthWest().lat, bbox.getNorthWest().lng],
                [bbox.getSouthWest().lat, bbox.getSouthWest().lng]
            ]).addTo(map1);

            // Zoom to the polygon
            map1.fitBounds(searchPolygonLayer.getBounds());
        }).addTo(map1);

        // Listen to the zoomend event and remove the search polygon layer
        map1.on('zoomend', function() {
            if (searchPolygonLayer) {
                map1.removeLayer(searchPolygonLayer);
                searchPolygonLayer = null;
            }
        });

        function resetMarkers() {
            initialCorner = null;
            directionPoint = null;
            map1.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    map1.removeLayer(layer);
                }
            });
        }

        // Define a custom icon for the dot markers
        const dotIcon = L.divIcon({
            className: 'custom-dot-icon',
            html: '<div style="width: 8px; height: 8px; background-color: red; border-radius: 50%;"></div>',
            iconSize: [8, 8],
            iconAnchor: [4, 4]
        });

        // Change cursor to dot when approaching the target area
        map1.on('mousemove', function(e) {
            map1.getContainer().style.cursor = 'crosshair';
        });

        // Reset cursor when leaving the map
        map1.on('mouseout', function(e) {
            map1.getContainer().style.cursor = '';
        });

        // Reset markers
        document.getElementById('reset-button').addEventListener('click', function() {
            resetMarkers();
        });

        function resetMarkers() {
            initialCorner = null;
            directionPoint = null;
            map1.eachLayer(function(layer) {
                if (layer instanceof L.Marker) {
                    map1.removeLayer(layer);
                }
            });
        }

    </script>
</body>
</html>